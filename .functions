#!/bin/bash
# shellcheck source=/dev/null

function play() { qdbus "org.mpris.MediaPlayer2.$1" /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Play; }
function pause() { qdbus "org.mpris.MediaPlayer2.$1" /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Pause; }
function movie() {
	vlc-fullscreen || return 1
	qdbus org.kde.Solid.PowerManagement /org/kde/Solid/PowerManagement/Actions/BrightnessControl setBrightness 0
	yakuake-retract
	pause spotify &>/dev/null
	play vlc
	ambilight movie vlc
	qdbus org.kde.Solid.PowerManagement /org/kde/Solid/PowerManagement/Actions/BrightnessControl setBrightness "$(qdbus org.kde.Solid.PowerManagement /org/kde/Solid/PowerManagement/Actions/BrightnessControl brightnessMax)"
}

weather() {
	curl "wttr.in/$1"
}

lights_off() {
	if [ -z "$1" ]; then
		sleep 5
	else
		sleep "$1"
	fi
	xset dpms force off
	ambilight off
}

caps() {
	if [ "$1" == "on" ]; then
		sudo sh -c "setleds -D +caps < /dev/console"
	else
		sudo sh -c "setleds -D -caps < /dev/console"
	fi
}

new-alias() {
	local last_cmd
	# shellcheck disable=SC2001
	last_cmd=$(history | tail -n2 | head -n1 | sed 's/[0-9]* //')
	echo alias "$1='""$last_cmd""'" >>~/.new_aliases
	source "$HOME/.new_aliases"
}

extract() {
	if [ -f "$1" ]; then
		case $1 in
		*.tar.bz2) tar xvjf "$1" ;;
		*.tar.gz) tar xvzf "$1";;
		*.bz2) bunzip2 "$1" ;;
		*.rar) unrar x "$1" ;;
		*.gz) gunzip "$1" ;;
		*.tar) tar xvf "$1" ;;
		*.tbz2) tar xvjf "$1" ;;
		*.tgz) tar xvzf "$1" ;;
		*.zip) unzip "$1" ;;
		*.Z) uncompress "$1" ;;
		*.7z) 7za x "$1" ;;
		*) echo "'$1' cannot be extracted via >extract<" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

checkkernel() {
	MSG="\e[1m\e[5m\e[31mALERT! \e[25mReboot system to apply crucial security updates.\e[0m"
	if [ -f /var/run/reboot-required ]; then
		echo -e "$MSG"
	fi
	if [ "$(rpm -q --last kernel | perl -pe 's/^kernel-(\S+).*/$1/' | head -1)" != "$(uname -r)" ]; then
		echo -e "$MSG"
	fi
}

shellcheck() {
	docker run --rm \
		-v "$(pwd):/project:z" \
		-w /project \
		koalaman/shellcheck-alpine:v0.5.0 shellcheck "${@}"
}

# Start computing
function compute() {
	WHICH="${1}"
	case $WHICH in
	"01") MAC="ec:f4:bb:43:a1:e8" ;;
	*) echo "Ups..." ;;
	esac
	HOST="compute${WHICH}"
	wol "${MAC}"
	until ping -c 1 "${HOST}" 1>/dev/null 2>&1; do
		sleep 2
	done
	sleep 10
	ssh "${HOST}"
}

function gpgreload() {
	local keyid="0x507ED6F6586DD37F"
	gpgconf --kill gpg-agent
	# shellcheck disable=SC2164
	( cd "$(gpgconf --list-dirs homedir)/private-keys-v1.d"; 
	gpg2 -K --with-keygrip --with-colons "$keyid" | \
	awk -F: '/^grp/ { print $10".key"; }' | \
	xargs rm -vf >/dev/null; )
	gpg-connect-agent "scd serialno" "learn --force" /bye >/dev/null 2>&1
}

function k8s-show-image() {
	kubectl get pods --all-namespaces -l app="${1}" -ojsonpath="{.items[*].spec.containers[?(@.name==\"$1\")].image}"
}

function k8s-po-show-rules() {
	kubectl -n prometheus-operator-e2e-tests exec -it prometheus-test-0 -c prometheus '/bin/sh -c "cat /etc/prometheus/rules/rules-0/test.rules"'
}


function up() {
	local msg="System update finished."
	if [ "$(dnf check-update --refresh 2>/dev/null | grep -c "grub\|kernel")" -gt 0 ]; then
		msg="$msg Reboot is required."
		if find -- "/boot" -prune -type d -empty | grep -q .; then
			echo "Cannot update system since /boot is empty."
			exit 1
		fi
	fi
	sudo dnf update
	flatpak update
	notify-send "$msg"
}

function clusterbot() {
	local file
	#shellcheck disable=SC2012,SC2086
	file=$(ls -t ${HOME}/Downloads/cluster-bot-*.kubeconfig | head -n1)
	if [ "$file" == "" ]; then
		echo "clusterbot kubeconfig file not found"
	else
		mv "$file" "$HOME/.kube/config.clusterbot"
		export KUBECONFIG="$HOME/.kube/config.clusterbot"
		kubectl get clusterversion
		export KUBECTL_NAMESPACE="openshift-monitoring"
	fi
}

todo() {
	if [ "$(date +%H)" -gt 18 ] || [ "$(date +%u)" -gt 5 ]; then
		# After work don't display TODO list
		return
	fi
	if [ -f "$HOME/Notes/TODO" ]; then
		echo -en "\e[1m\e[32m"
		echo "Things to do in next days:"
		echo -en "\e[0m\e[33m"
		cat "$HOME/Notes/TODO"
		echo -en "\e[0m"
	fi
}

todoedit() {
	vim "$HOME/Notes/TODO"
}

e2e() {
	if [ "$(basename "$(pwd)")" != "prometheus-operator" ]; then
		echo "Not in prometheus-operator directory"
		return
	fi
	kind delete cluster
	kind create cluster
	export KUBECONFIG="$(kind get kubeconfig-path)"
	make image
	for n in "operator" "config-reloader"; do
		kind load docker-image "quay.io/coreos/prometheus-$n:$(git rev-parse --short HEAD)"
	done
	until [ "$(kubectl get pods -n kube-system --field-selector=status.phase==Running | wc -l )" -eq 9 ]; do
		echo "Waiting for cluster to finish bootstraping"
		sleep 5
	done
	make test-e2e
}

picsort() {
  exiftool -ext jpg '-FileName<CreateDate' -d %Y_%m_%d__%H_%M_%S%%-c.%%e .
  X=1
  for i in *; do
    mv "$i" "$(printf %04d.%s ${X%.*} "${i##*.}")"
    X="$((X+1))"
  done
}

function timer() {
	#TODO: better timer which supports seconds precision
	local length="$1"
	local suffix
	case "${length: -1}" in
	#"s") suffix="seconds";;
	"m") suffix="minutes";;
	"h") suffix="seconds";;
	*) exit 0;;
	esac
	at now +${length::-1} $suffix <<< "notify-send \"Timer for $1 finished.\""
}

function monitor() {
	local WHICH="$1"
	local COMMAND="xrandr --output eDP1 --mode 1920x1080 "
	case "$1" in
	"lg") PARAMS="--output DP1 --mode 3440x1440 --right-of eDP1" ;;
	"projector") PARAMS="--output HDMI1 --mode 1920x1080 --right-of eDP1" ;;
	*) PARAMS="--output DP1 --off --output HDMI1 --off" ;;
	esac
	
	echo "Setting up screens configuration"
	eval $COMMAND $PARAMS
	echo "Re-applying screen configuration in 5 second..."
	sleep 5
	eval $COMMAND $PARAMS
}

function sshcopyid() {
	local host
	host="$1"
	ssh-copy-id "$host"
	for id in $HOME/.ssh/id_*.pub; do
		echo "$id"
		ssh-copy-id -f -i "$id" "$host"
	done
}

function buildx-init() {
	docker run --rm --privileged docker/binfmt:820fdd95a9972a5308930a2bdfb8573dd4447ad3
	docker buildx create --name mybuilder --use
	docker buildx inspect --bootstrap
}

function buildx-cross() {
	image=${1}
	for arch in amd64 arm64 arm; do
		docker buildx build --platform linux/${arch} -t "${image}-${arch}" --load .
		docker push "${image}-${arch}"
	done
	manifest-tool push from-args --platforms linux/amd64,linux/arm64,linux/arm  --template "${image}-ARCH" --target "${image}"
}

